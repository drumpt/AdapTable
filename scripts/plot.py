#!/usr/bin/env python
# coding: utf-8

# In[5]:


import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np
import csv

# source = 'shapenet'
# target = 'modelnet'
# with open(f'features2/pl_abl/{source}_to_{target}_trgt_feats.pkl', 'rb') as f:
#     features_ori = pickle.load(f)
# with open(f'gts2/{target}_train_gt.pkl', 'rb') as f:
#     gt = pickle.load(f)
# with open(f'pseudo_labels2/{source}_to_{target}_pl.pkl', 'rb') as f:
#     pseudo_labels = pickle.load(f)
    
# tgt_dist = np.zeros(10).astype(np.int)
# for lb in gt:
#     tgt_dist[lb] += 1
# pl_dist = pseudo_labels.sum(axis=0).astype(np.int)
    
####### shape -> model #######
#src_dist = np.array([126.0, 33.0, 53.0, 202.0, 881.0, 316.0, 155.0, 28.0, 444.0, 1106.0]).astype(np.int)
#tgt_dist = np.array([86.0, 410.0, 458.0, 159.0, 711.0, 100.0, 371.0, 191.0, 544.0, 314.0]).astype(np.int)
#pl_dist = np.array([90.0, 0.0, 45.0, 16.0, 721.0, 111.0, 354.0, 56.0, 571.0, 435.0]).astype(np.int)
# src_dist = np.array([103.0, 32.0, 60.0, 209.0, 856.0, 310.0, 164.0, 34.0, 453.0, 1123.0]).astype(np.int)


##### cmc numerical 1
# source_label_list = np.unique(np.array([1, 2, 2, 0, 0, 0, 0, 2, 2, 1, 0, 0, 1, 2, 0, 2, 2, 2, 0, 2, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 1, 1, 2, 0, 2, 0, 1, 1, 2, 2, 2, 0, 0, 2, 1, 1, 1, 0, 0, 2, 0, 0, 2, 2, 0, 1, 1, 0, 2, 0, 2, 2, 2, 1, 2, 1, 2, 0, 2, 1, 1, 0, 0, 2, 1, 2, 2, 2, 1, 0, 1, 0, 2, 0, 1, 0, 1, 0, 0, 2, 2, 2, 1, 2, 0, 2, 2, 2, 2, 1, 0, 2, 2, 0, 1, 0, 0, 1, 2, 1, 0, 2, 1, 2, 2, 0, 0, 1, 0, 1, 2, 0, 2, 1, 0, 0, 1, 2, 1, 1, 0, 1, 0, 0, 2, 1, 2, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 1, 2, 2, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 2, 1, 1, 1, 1, 2, 2, 1, 0, 1, 2, 0, 0, 1, 2, 2, 0, 0, 1, 1, 0, 2, 2, 1, 2, 1, 0, 1, 1, 2, 0, 2, 0, 2, 1, 2, 1, 2, 0, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 0, 2, 0, 0, 1, 2, 1, 0, 0, 0, 2, 1, 2, 2, 0, 0, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 2, 0, 0, 2, 1, 0, 2, 1, 2, 0, 0, 2, 0, 2, 0, 2, 2, 1, 0, 2, 0, 0, 2, 1, 0, 2, 1, 2, 0, 2, 1, 1, 2, 0, 2, 2, 2, 0, 1, 2, 1, 2, 1, 2, 1, 0, 2, 1, 2, 2, 0, 0, 0, 1, 0, 2, 2, 0, 2, 0, 2, 0, 0, 2, 2, 0, 1, 0, 0, 1, 1, 2, 0, 2, 1, 0, 0, 2, 2, 2, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 2, 2, 1, 1, 0, 2, 0, 1, 2, 2, 0, 2, 1, 0, 0, 0, 2, 0, 1, 0, 2, 1, 2, 2, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 2, 2, 2, 2, 0, 1, 2, 2, 0, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 2, 0, 0, 1, 1, 2, 1, 2, 1, 2, 2, 2, 0, 0, 0, 2, 0, 1, 2, 2, 1, 0, 0, 2, 2, 0, 1, 1, 0, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 0, 2, 0, 2, 1, 2, 1, 2, 0, 1, 0, 1, 0, 1, 0, 0, 2, 1, 0, 2, 2, 1, 2, 0, 1, 2, 1, 0, 1, 1, 2, 0, 2, 1, 0, 0, 0, 2, 1, 2, 1, 2, 1, 0, 1, 2, 0, 1, 2, 2, 0, 1, 0, 1, 2, 0, 2, 0, 2, 1, 0, 2, 2, 2, 0, 1, 2, 1, 2, 0, 2, 2, 2, 1, 1, 1, 1, 1, 0, 2, 2, 1, 1, 1, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 1, 2, 0, 1, 2, 2, 2, 2, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 1, 2, 0, 2, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 2, 0, 2, 0, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 2, 0, 0, 0, 1, 2, 0, 2, 2, 0, 2, 0, 0, 0, 2, 0, 0, 1, 2, 2, 2, 2, 2, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 0, 2, 2, 0, 2, 0, 1, 0, 1, 2, 0, 1, 2, 0, 2, 1, 1, 0, 2, 1, 0, 2, 0, 0, 1, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1, 2, 0, 0, 1, 2, 1, 2, 0, 1, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 1, 0, 2, 2, 1, 1, 2, 0, 1, 2, 2, 2, 1, 2, 0, 1, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 1, 0, 1, 1, 2, 0, 2, 0, 1, 0, 0, 2, 2, 2, 1, 2, 2, 1, 2, 0, 0, 0, 1, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 0, 1, 1, 0, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 0, 2, 1, 0, 0, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 0, 2, 0, 1, 0, 1, 0, 2, 0, 2, 2, 1, 2, 0, 0, 1, 1, 2, 0, 1, 2, 2, 0, 2, 0, 2, 2, 1, 2, 2, 1, 1, 0, 2, 2, 0, 2, 2, 2, 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 1, 2, 1, 1, 0, 0, 1, 1, 2, 1, 0, 1, 1, 0, 0, 2, 2, 1, 0, 0, 1, 2, 0, 2, 1, 2, 2, 2, 1, 2, 2, 2, 0, 1, 0, 2, 2, 0, 2, 2, 1]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 2, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 2, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 0, 2, 0, 2, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 2, 0, 2, 2, 0, 1, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 1, 1, 2, 0, 2, 2, 0, 2, 2, 2, 0, 1, 2, 1, 2, 0, 2, 1, 0, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 0, 2, 2, 2, 1, 1, 1, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 0, 2, 2, 0, 2, 1, 2, 0, 0, 0, 1, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 1, 2, 2, 0, 0, 2, 2, 1, 2, 2, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 1, 2, 0, 2, 2, 0, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 2, 1, 2, 2, 0, 2, 2, 2, 2, 2]), return_counts=True)[1]
# source_label_list = np.unique(np.array([0, 1, 0, 0, 2, 2, 0, 1, 1, 0, 1, 0, 1, 0, 2, 0, 0, 1, 1, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 1, 2, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 2, 0, 2, 2, 2, 0, 1, 2, 0, 0, 0, 0, 0, 2, 0, 1, 1, 2, 0, 0, 1, 2, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 1, 2, 2, 2, 2, 2, 0, 0, 1, 1, 0, 2, 2, 2, 1, 0, 2, 2, 0, 1, 0, 2, 1, 2, 2, 1, 2, 0, 0, 1, 2, 2, 0, 1, 0, 2, 2, 1, 0, 2, 2, 2, 2, 0, 0, 1, 2, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 2, 2, 2, 1, 0, 0, 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 0, 2, 1, 0, 1, 2, 0, 0, 0, 2, 0, 2, 2, 0, 1, 2, 1, 2, 2, 0, 0, 0, 0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 2, 2, 1, 1, 0, 0, 2, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2, 0, 1, 0, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 0, 0, 2, 0, 0, 2, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 2, 0, 2, 2, 1, 2, 0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 1, 2, 0, 1, 0, 0, 2, 2, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 2, 2, 0, 0, 0, 1, 2, 2, 2, 1, 2, 1, 2, 0, 1, 0, 2, 2, 0, 1, 2, 1, 1, 0, 1, 0, 2, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 2, 0, 2, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 0, 1, 0, 0, 2, 1, 0, 0, 1, 0, 1, 0, 0, 2, 1, 2, 2, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 0, 1, 2, 2, 0, 2, 2, 1, 1, 2, 0, 0, 2, 1, 0, 0, 1, 0, 2, 1, 0, 0, 2, 0, 0, 0, 1, 0, 1, 1, 2, 0, 2, 2, 2, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 2, 1, 0, 1, 2, 1, 1, 1, 2, 0, 2, 1, 2, 2, 2, 0, 2, 0, 2, 2, 0, 0, 2, 0, 2, 1, 0, 2, 0, 2, 2, 0, 0, 1, 2, 0, 2, 1, 0, 0, 2, 0, 2, 1, 1, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 0, 2, 0, 2, 1, 1, 0, 2, 1, 0, 0, 0, 1, 0, 2, 2, 0, 0, 2, 0, 0, 0, 2, 0, 2, 1, 0, 0, 0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 2, 0, 0, 2, 1, 1, 2, 1, 1, 2, 1, 0, 1, 2, 2, 0, 0, 2, 1, 2, 0, 2, 2, 0, 1, 1, 1, 1, 2, 2, 0, 0, 1, 1, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 1, 0, 1, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 2, 0, 1, 1, 1, 2, 0, 0, 0, 2, 1, 1, 0, 1, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 0, 2, 1, 0, 1, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 1, 0, 0, 1, 1, 1, 0, 2, 2, 2, 1, 1, 1, 0, 2, 2, 0, 2, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 1, 1, 1, 2, 1, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 2, 0, 1, 1, 1, 0, 2, 1, 2, 2, 0, 1, 0, 1, 0, 2, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 2, 0, 1, 2, 2, 2, 1, 1, 0, 2, 0, 2, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 2, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 0, 2, 0, 1, 2, 1, 0, 0, 2, 0, 1, 0, 1, 2, 2, 2, 0, 2, 0, 1, 2, 0, 2, 2, 2, 1, 2, 1, 2, 2, 0, 2, 0, 1, 2, 1, 1, 0, 0, 0, 2, 0, 1, 2, 1, 1, 1, 0, 1, 1, 1, 2, 2, 1, 1, 0, 2, 2, 0, 0, 2, 2, 0, 1, 1, 0, 0, 0, 2, 1, 2, 0, 1, 2, 0, 1, 2, 1, 1, 2, 2, 2, 2, 0, 2, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 2, 0, 1, 1, 0, 2, 2, 2, 2, 1, 1, 2, 2, 1]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 1, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 0, 1, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 1, 2, 0, 0, 0, 2, 0, 1, 1, 0, 1, 1, 2, 1, 0, 2, 1, 2, 2, 2, 0, 0, 2, 0, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 1, 1, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 1, 1, 0, 2, 2, 2, 0, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 1, 2, 0, 2, 0, 0, 2, 2, 0]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2, 2, 1, 0, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 0, 0, 2, 2, 2, 1, 1, 2, 2, 1, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 1, 0, 1, 2, 1, 0, 2, 0, 0, 2, 2, 0, 0, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 1, 0, 0, 2, 2, 1, 1, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 1, 2, 0, 2, 0, 0, 2, 2, 2]), return_counts=True)[1]
# source_label_list = np.unique(np.array([0, 0, 2, 2, 2, 0, 1, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2, 2, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 1, 2, 0, 2, 0, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 1, 1, 0, 2, 0, 2, 1, 2, 0, 1, 0, 1, 2, 1, 0, 0, 0, 2, 2, 2, 1, 2, 2, 2, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 2, 1, 2, 0, 2, 0, 1, 2, 2, 0, 2, 2, 1, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, 0, 2, 0, 1, 1, 2, 0, 0, 0, 0, 1, 0, 2, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 1, 2, 2, 2, 0, 0, 1, 0, 1, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 0, 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 1, 0, 2, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 1, 2, 1, 0, 2, 1, 2, 1, 1, 1, 1, 2, 2, 0, 0, 2, 1, 2, 0, 1, 0, 1, 0, 0, 2, 1, 0, 1, 0, 2, 0, 2, 0, 2, 2, 1, 2, 2, 0, 0, 1, 2, 0, 2, 0, 0, 0, 2, 0, 2, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0, 1, 2, 0, 0, 1, 2, 0, 0, 2, 2, 2, 0, 2, 0, 2, 2, 0, 1, 2, 0, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 0, 1, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 1, 0, 2, 2, 2, 0, 0, 0, 0, 2, 0, 1, 0, 2, 2, 0, 0, 2, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 2, 0, 2, 2, 1, 1, 0, 2, 1, 2, 0, 1, 0, 0, 0, 0, 2, 1, 1, 0, 2, 0, 0, 2, 0, 2, 1, 0, 1, 0, 2, 0, 1, 2, 1, 0, 1, 1, 2, 0, 2, 1, 2, 0, 1, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 1, 1, 0, 0, 1, 1, 2, 0, 2, 2, 0, 1, 2, 0, 2, 0, 0, 0, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, 0, 2, 2, 2, 1, 0, 0, 2, 2, 0, 2, 2, 0, 2, 1, 2, 1, 2, 0, 2, 1, 1, 1, 2, 0, 0, 2, 0, 1, 0, 1, 2, 0, 2, 2, 1, 2, 2, 2, 0, 2, 1, 0, 0, 0, 2, 2, 1, 2, 0, 1, 0, 0, 1, 0, 0, 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 0, 2, 2, 1, 2, 2, 1, 0, 2, 1, 1, 1, 1, 2, 1, 2, 0, 1, 2, 0, 2, 1, 0, 0, 0, 0, 2, 1, 0, 2, 2, 1, 2, 0, 0, 2, 2, 0, 2, 0, 2, 0, 1, 2, 2, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 1, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 0, 1, 0, 1, 2, 0, 0, 0, 1, 0, 2, 2, 0, 1, 0, 2, 2, 0, 2, 0, 2, 0, 1, 0, 0, 1, 1, 0, 2, 1, 1, 1, 2, 2, 2, 0, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 1, 0, 2, 1, 2, 1, 2, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 0, 1, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 1, 2, 1, 0, 1, 2, 0, 2, 0, 0, 2, 1, 0, 0, 2, 2, 0, 2, 1, 1, 2, 0, 1, 0, 0, 0, 0, 1, 1, 2, 0, 2, 1, 0, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 1, 0, 2, 2, 2, 2, 0, 0, 0, 2, 0, 1, 1, 1, 2, 0, 1, 1, 2, 0, 0, 1, 2, 1, 2, 0, 2, 2, 2, 2, 1, 0, 2, 2, 2, 0, 1, 2, 2, 2, 1, 2, 0, 0, 2, 0, 2, 2, 1, 1, 1, 0, 2, 2, 1, 2, 2, 0, 1, 1, 1, 2, 0, 0, 2, 0, 1, 2, 2, 2, 2, 0, 2, 0, 2, 2, 1, 2, 2, 2, 0, 0, 2, 0, 0, 2, 0, 1, 0, 1, 0, 2, 0, 2, 2, 2, 1, 2, 2, 0, 2, 1, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 1, 1, 2, 1, 2, 0, 1, 0, 0, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 2, 2, 1, 0, 0, 1, 0, 2, 0, 1, 2, 0, 2, 1, 0, 1, 1, 2, 1, 2, 0, 0, 1, 1, 2, 2, 0, 1, 0, 2, 0, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 0, 1, 2, 0, 0, 0]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 1, 2, 0, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 1, 0, 1, 2, 2, 2, 0, 2, 0, 1, 1, 2, 0, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 1, 2, 0, 2, 0, 0, 2, 1, 1, 2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 1, 0, 0, 0, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 1, 1, 0, 0, 1, 1, 1, 0, 2, 2, 1, 2, 2, 2, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 2, 1, 1, 2, 1, 0, 2, 2, 2, 2, 1, 2, 0, 2, 2, 1, 1, 1, 0, 1, 0, 0, 2, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2]), return_counts=True)[1]

# source_label_list = [369, 213, 301]
# target_label_list = [141, 52, 102]
# pseudo_label_list = [151, 44, 100]
# modified_label_list = [152, 53, 90]

# source_label_list = [358, 206, 318]
# target_label_list = [157, 54, 85]
# pseudo_label_list = [142, 31, 123]
# modified_label_list = [141, 51, 104]

source_label_list = [1685, 535]
target_label_list = [2980, 3934]
pseudo_label_list = [5745, 1169]
# pseudo_label_list = [6211,  703]
modified_label_list = [3800, 3114]

# source_label_list = list(map(lambda x: float(x), source_label_list))
# target_label_list = list(map(lambda x: float(x), target_label_list))
# pseudo_label_list = list(map(lambda x: float(x), pseudo_label_list))
# modified_label_list = list(map(lambda x: float(x), modified_label_list))

# source_label_list /= np.sum(source_label_list)
# target_label_list /= np.sum(target_label_list)
# pseudo_label_list /= np.sum(pseudo_label_list)
# modified_label_list /= np.sum(modified_label_list)

# print(f"source_label_list: {source_label_list}")
# print(f"target_label_list: {target_label_list}")
# print(f"pseudo_label_list: {pseudo_label_list}")
# print(f"modified_label_list: {modified_label_list}")

for i in range(len(source_label_list)):
    if i == 0:
        src_density = np.ones(source_label_list[i]) * i
        trgt_density = np.ones(target_label_list[i]) * i
        pl_density = np.ones(pseudo_label_list[i]) * i
        ml_density = np.ones(modified_label_list[i]) * i
    else:
        src_density = np.concatenate((src_density, np.ones(source_label_list[i]) * i))
        trgt_density = np.concatenate((trgt_density, np.ones(target_label_list[i]) * i))
        pl_density = np.concatenate((pl_density, np.ones(pseudo_label_list[i]) * i))
        ml_density = np.concatenate((ml_density, np.ones(modified_label_list[i]) * i))
classes = np.arange(2)

# colors = ['#ff8c00', '#009905', '#0077ff', '#0077ff'] 
colors2 = ['#EA3D5F', '#F6C84A', '#5DCA76', '#4398D8']
# colors3 = ['#E7298A', '#1B9E77', '#7570B3', '#0077ff']
names = ['Source Label Distribution', 'Target Label Distribution', 'Pseudo Label Distribution', 'Label Distribution Handler (Ours)']
width = 0.26  # the width of the bars
fig, axes = plt.subplots(1, 4, figsize=(48, 8.5))
distributions = [source_label_list, target_label_list, pseudo_label_list, modified_label_list]
densities = [src_density, trgt_density, pl_density, ml_density]

titles = ['(a) Source Label Distribution', '(b) Target Label Distribution', '(c) Pseudo Label Distribution', '(d) Label Distribution Handler (Ours)']

for i, (dist, dens) in enumerate(zip(distributions, densities)):
    ax = axes[i]
    for axis in ['top','bottom','left','right']:
        ax.spines[axis].set_linewidth(2)

    # ax.hist(dens, range(len(source_label_list) + 1), color=colors2[i], density=True, alpha=0.68, rwidth=0.85, align='left', label=names[i])
    # sns.kdeplot(dens, ax=ax, color=colors2[i], alpha=0.28, bw_adjust=2.5, fill=True, linewidth=0.2)
    ax.hist(dens, range(len(source_label_list) + 1), color=colors2[i], density=True, alpha=0.5, rwidth=0.85, align='left', label=names[i])
    sns.kdeplot(dens, ax=ax, color=colors2[i], alpha=0.28, bw_adjust=6, fill=True, linewidth=0.2)
    ax.set_ylabel('Ratio', fontsize=38)
    ax.set_xlabel('Label', fontsize=38)
    ax.set_xticks(range(len(source_label_list)))
    ax.set_title(titles[i], y=1.03, fontsize=42)
    # ax.set_ylim(0, 0.55)
    ax.set_ylim(0, 1)
    ax.tick_params(labelsize=38)


# # add cls-wise conf.    
# g = open('wandb_shapetomodel_clswiseconf.csv', 'r', encoding='utf-8')
# rdr = csv.reader(g)
# cls_conf_2 = [[],[], [],[],[],[],[],[],[],[]]
# for line in rdr:
#     if 'Cls' in line[1]:
#         cls_conf_2[int(line[1][-1])].append(float(line[2]))

# x_epoch = list(range(1,151))
# ax = axes[3]
# ax.set_title("(d) Class-wise Confidence \n for Intra-class Data",y=-0.29, fontsize=35)
# ax.set_ylabel('Confidence',fontsize=26)
# ax.set_xlabel(r'Epoch',fontsize=29)
# ax.tick_params(labelsize=22)
# ax.set_xlim([0,155])
# ax.grid(True, linewidth=0.5)

# colors = ['#cde3f6', '#9bc7ec', '#69abe3', '#378fd9', '#2271b3', '#f6dfcd', '#ecbf9b', '#e3a069', '#d98037', '#b36322']
# colors = ['black', '#b36322', '#d98037', 'black', '#2271b3', 'black', 'black', '#e3a069', '#378fd9', '#69abe3']

# cls_order =[4,8,9, 1,2,7]
# for i in cls_order:
#     if colors[i] == 'black':
#         continue
#     if i in [4,8,9]:
#         cls = 'major'
#     else:
#         cls = 'minor'
#     ax.plot(x_epoch, cls_conf_2[i], linestyle='-', linewidth=2.5, color=colors[i], label=f'{cls} class (Class {i})')
# ax.legend(loc='lower right',fontsize=19,numpoints=1)

plt.show()
# plt.savefig(f'{source}_to_{target}_remark3.3.pdf', facecolor=fig.get_facecolor(), bbox_inches='tight', format='pdf',pad_inches=0.1, dpi=600)


# In[4]:


import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np
import csv

# source = 'shapenet'
# target = 'modelnet'
# with open(f'features2/pl_abl/{source}_to_{target}_trgt_feats.pkl', 'rb') as f:
#     features_ori = pickle.load(f)
# with open(f'gts2/{target}_train_gt.pkl', 'rb') as f:
#     gt = pickle.load(f)
# with open(f'pseudo_labels2/{source}_to_{target}_pl.pkl', 'rb') as f:
#     pseudo_labels = pickle.load(f)
    
# trgt_dist = np.zeros(10).astype(np.int)
# for lb in gt:
#     trgt_dist[lb] += 1
# pl_dist = pseudo_labels.sum(axis=0).astype(np.int)
    
####### shape -> model #######
#src_dist = np.array([126.0, 33.0, 53.0, 202.0, 881.0, 316.0, 155.0, 28.0, 444.0, 1106.0]).astype(np.int)
#trgt_dist = np.array([86.0, 410.0, 458.0, 159.0, 711.0, 100.0, 371.0, 191.0, 544.0, 314.0]).astype(np.int)
#pl_dist = np.array([90.0, 0.0, 45.0, 16.0, 721.0, 111.0, 354.0, 56.0, 571.0, 435.0]).astype(np.int)
# src_dist = np.array([103.0, 32.0, 60.0, 209.0, 856.0, 310.0, 164.0, 34.0, 453.0, 1123.0]).astype(np.int)


##### cmc numerical 1
# source_label_list = np.unique(np.array([1, 2, 2, 0, 0, 0, 0, 2, 2, 1, 0, 0, 1, 2, 0, 2, 2, 2, 0, 2, 0, 0, 0, 1, 0, 1, 2, 2, 2, 2, 1, 1, 2, 0, 2, 0, 1, 1, 2, 2, 2, 0, 0, 2, 1, 1, 1, 0, 0, 2, 0, 0, 2, 2, 0, 1, 1, 0, 2, 0, 2, 2, 2, 1, 2, 1, 2, 0, 2, 1, 1, 0, 0, 2, 1, 2, 2, 2, 1, 0, 1, 0, 2, 0, 1, 0, 1, 0, 0, 2, 2, 2, 1, 2, 0, 2, 2, 2, 2, 1, 0, 2, 2, 0, 1, 0, 0, 1, 2, 1, 0, 2, 1, 2, 2, 0, 0, 1, 0, 1, 2, 0, 2, 1, 0, 0, 1, 2, 1, 1, 0, 1, 0, 0, 2, 1, 2, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 0, 2, 1, 2, 2, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 2, 1, 1, 1, 1, 2, 2, 1, 0, 1, 2, 0, 0, 1, 2, 2, 0, 0, 1, 1, 0, 2, 2, 1, 2, 1, 0, 1, 1, 2, 0, 2, 0, 2, 1, 2, 1, 2, 0, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 1, 1, 2, 2, 2, 1, 2, 0, 2, 0, 0, 1, 2, 1, 0, 0, 0, 2, 1, 2, 2, 0, 0, 2, 1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 2, 0, 0, 2, 1, 0, 2, 1, 2, 0, 0, 2, 0, 2, 0, 2, 2, 1, 0, 2, 0, 0, 2, 1, 0, 2, 1, 2, 0, 2, 1, 1, 2, 0, 2, 2, 2, 0, 1, 2, 1, 2, 1, 2, 1, 0, 2, 1, 2, 2, 0, 0, 0, 1, 0, 2, 2, 0, 2, 0, 2, 0, 0, 2, 2, 0, 1, 0, 0, 1, 1, 2, 0, 2, 1, 0, 0, 2, 2, 2, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 2, 2, 1, 1, 0, 2, 0, 1, 2, 2, 0, 2, 1, 0, 0, 0, 2, 0, 1, 0, 2, 1, 2, 2, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 2, 2, 2, 2, 0, 1, 2, 2, 0, 1, 2, 1, 1, 0, 2, 0, 0, 1, 1, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 2, 0, 0, 1, 1, 2, 1, 2, 1, 2, 2, 2, 0, 0, 0, 2, 0, 1, 2, 2, 1, 0, 0, 2, 2, 0, 1, 1, 0, 2, 2, 2, 1, 1, 1, 1, 2, 2, 1, 1, 2, 0, 2, 0, 2, 1, 2, 1, 2, 0, 1, 0, 1, 0, 1, 0, 0, 2, 1, 0, 2, 2, 1, 2, 0, 1, 2, 1, 0, 1, 1, 2, 0, 2, 1, 0, 0, 0, 2, 1, 2, 1, 2, 1, 0, 1, 2, 0, 1, 2, 2, 0, 1, 0, 1, 2, 0, 2, 0, 2, 1, 0, 2, 2, 2, 0, 1, 2, 1, 2, 0, 2, 2, 2, 1, 1, 1, 1, 1, 0, 2, 2, 1, 1, 1, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 1, 2, 0, 1, 2, 2, 2, 2, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 1, 2, 0, 2, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 2, 0, 2, 0, 0, 1, 2, 0, 1, 0, 1, 0, 1, 2, 1, 1, 1, 0, 0, 0, 1, 2, 2, 2, 2, 0, 0, 0, 1, 2, 0, 2, 2, 0, 2, 0, 0, 0, 2, 0, 0, 1, 2, 2, 2, 2, 2, 1, 2, 0, 1, 1, 0, 0, 2, 0, 1, 0, 2, 2, 0, 2, 0, 1, 0, 1, 2, 0, 1, 2, 0, 2, 1, 1, 0, 2, 1, 0, 2, 0, 0, 1, 0, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1, 2, 0, 0, 1, 2, 1, 2, 0, 1, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 1, 0, 2, 2, 1, 1, 2, 0, 1, 2, 2, 2, 1, 2, 0, 1, 0, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 1, 0, 1, 1, 2, 0, 2, 0, 1, 0, 0, 2, 2, 2, 1, 2, 2, 1, 2, 0, 0, 0, 1, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 0, 1, 1, 0, 2, 2, 2, 0, 2, 0, 0, 2, 2, 2, 0, 2, 1, 0, 0, 2, 2, 1, 2, 1, 2, 2, 2, 2, 1, 2, 0, 2, 0, 1, 0, 1, 0, 2, 0, 2, 2, 1, 2, 0, 0, 1, 1, 2, 0, 1, 2, 2, 0, 2, 0, 2, 2, 1, 2, 2, 1, 1, 0, 2, 2, 0, 2, 2, 2, 1, 0, 0, 0, 1, 0, 2, 0, 0, 2, 1, 2, 1, 1, 0, 0, 1, 1, 2, 1, 0, 1, 1, 0, 0, 2, 2, 1, 0, 0, 1, 2, 0, 2, 1, 2, 2, 2, 1, 2, 2, 2, 0, 1, 0, 2, 2, 0, 2, 2, 1]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 2, 1, 0, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 2, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 0, 2, 0, 2, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 2, 0, 2, 2, 0, 1, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 1, 1, 2, 0, 2, 2, 0, 2, 2, 2, 0, 1, 2, 1, 2, 0, 2, 1, 0, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 0, 2, 2, 2, 1, 1, 1, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 1, 2, 0, 2, 0, 2, 0, 1, 0, 2, 0, 0, 2, 2, 0, 2, 1, 2, 0, 0, 0, 1, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 1, 2, 2, 0, 0, 2, 2, 1, 2, 2, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 1, 2, 0, 2, 2, 0, 2, 2, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 2, 1, 2, 2, 0, 2, 2, 2, 2, 2]), return_counts=True)[1]
# source_label_list = np.unique(np.array([0, 1, 0, 0, 2, 2, 0, 1, 1, 0, 1, 0, 1, 0, 2, 0, 0, 1, 1, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 1, 2, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 2, 2, 0, 2, 2, 2, 0, 1, 2, 0, 0, 0, 0, 0, 2, 0, 1, 1, 2, 0, 0, 1, 2, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 0, 0, 1, 2, 2, 2, 2, 2, 0, 0, 1, 1, 0, 2, 2, 2, 1, 0, 2, 2, 0, 1, 0, 2, 1, 2, 2, 1, 2, 0, 0, 1, 2, 2, 0, 1, 0, 2, 2, 1, 0, 2, 2, 2, 2, 0, 0, 1, 2, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 2, 2, 2, 1, 0, 0, 2, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 0, 2, 1, 0, 1, 2, 0, 0, 0, 2, 0, 2, 2, 0, 1, 2, 1, 2, 2, 0, 0, 0, 0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 2, 1, 2, 2, 1, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 2, 2, 1, 1, 0, 0, 2, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2, 0, 1, 0, 1, 0, 0, 0, 2, 1, 0, 2, 1, 0, 1, 0, 0, 2, 0, 0, 2, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 2, 0, 2, 2, 1, 2, 0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 1, 2, 0, 1, 0, 0, 2, 2, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 2, 2, 0, 0, 0, 1, 2, 2, 2, 1, 2, 1, 2, 0, 1, 0, 2, 2, 0, 1, 2, 1, 1, 0, 1, 0, 2, 0, 0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 2, 2, 0, 2, 0, 2, 1, 2, 0, 2, 2, 1, 2, 0, 0, 1, 0, 0, 2, 1, 0, 0, 1, 0, 1, 0, 0, 2, 1, 2, 2, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 0, 1, 2, 2, 0, 2, 2, 1, 1, 2, 0, 0, 2, 1, 0, 0, 1, 0, 2, 1, 0, 0, 2, 0, 0, 0, 1, 0, 1, 1, 2, 0, 2, 2, 2, 0, 2, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 2, 1, 0, 1, 2, 1, 1, 1, 2, 0, 2, 1, 2, 2, 2, 0, 2, 0, 2, 2, 0, 0, 2, 0, 2, 1, 0, 2, 0, 2, 2, 0, 0, 1, 2, 0, 2, 1, 0, 0, 2, 0, 2, 1, 1, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 0, 2, 0, 2, 1, 1, 0, 2, 1, 0, 0, 0, 1, 0, 2, 2, 0, 0, 2, 0, 0, 0, 2, 0, 2, 1, 0, 0, 0, 2, 0, 0, 1, 2, 1, 0, 0, 2, 2, 0, 0, 2, 1, 1, 2, 1, 1, 2, 1, 0, 1, 2, 2, 0, 0, 2, 1, 2, 0, 2, 2, 0, 1, 1, 1, 1, 2, 2, 0, 0, 1, 1, 0, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 1, 0, 1, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 2, 0, 1, 1, 1, 2, 0, 0, 0, 2, 1, 1, 0, 1, 2, 1, 2, 2, 2, 1, 1, 2, 1, 1, 2, 2, 1, 2, 0, 2, 1, 0, 1, 2, 2, 0, 0, 2, 0, 0, 2, 0, 2, 1, 0, 0, 1, 1, 1, 0, 2, 2, 2, 1, 1, 1, 0, 2, 2, 0, 2, 1, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 2, 0, 2, 0, 0, 2, 0, 0, 0, 0, 2, 1, 1, 1, 2, 1, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 0, 2, 0, 1, 1, 1, 0, 2, 1, 2, 2, 0, 1, 0, 1, 0, 2, 2, 2, 0, 0, 2, 2, 1, 2, 0, 0, 2, 0, 1, 2, 2, 2, 1, 1, 0, 2, 0, 2, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 2, 1, 1, 2, 2, 0, 2, 1, 0, 1, 0, 2, 0, 2, 2, 2, 2, 0, 0, 0, 0, 2, 0, 2, 0, 1, 2, 1, 0, 0, 2, 0, 1, 0, 1, 2, 2, 2, 0, 2, 0, 1, 2, 0, 2, 2, 2, 1, 2, 1, 2, 2, 0, 2, 0, 1, 2, 1, 1, 0, 0, 0, 2, 0, 1, 2, 1, 1, 1, 0, 1, 1, 1, 2, 2, 1, 1, 0, 2, 2, 0, 0, 2, 2, 0, 1, 1, 0, 0, 0, 2, 1, 2, 0, 1, 2, 0, 1, 2, 1, 1, 2, 2, 2, 2, 0, 2, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 2, 0, 1, 1, 0, 2, 2, 2, 2, 1, 1, 2, 2, 1]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 1, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 0, 1, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 1, 2, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 1, 2, 0, 0, 0, 2, 0, 1, 1, 0, 1, 1, 2, 1, 0, 2, 1, 2, 2, 2, 0, 0, 2, 0, 2, 1, 2, 0, 2, 0, 0, 0, 0, 2, 2, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 1, 1, 0, 0, 0, 0, 0, 2, 2, 1, 1, 0, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 2, 2, 0, 0, 2, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 2, 1, 1, 0, 2, 2, 2, 0, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 1, 2, 0, 2, 0, 0, 2, 2, 0]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2, 2, 1, 0, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 0, 0, 2, 2, 2, 1, 1, 2, 2, 1, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 1, 0, 1, 2, 1, 0, 2, 0, 0, 2, 2, 0, 0, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 2, 1, 0, 0, 2, 2, 1, 1, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 2, 1, 2, 0, 2, 0, 0, 2, 2, 2]), return_counts=True)[1]
# source_label_list = np.unique(np.array([0, 0, 2, 2, 2, 0, 1, 0, 1, 0, 0, 1, 0, 2, 0, 1, 2, 2, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 1, 2, 0, 2, 0, 2, 2, 1, 2, 2, 0, 0, 2, 0, 0, 2, 1, 1, 0, 2, 0, 2, 1, 2, 0, 1, 0, 1, 2, 1, 0, 0, 0, 2, 2, 2, 1, 2, 2, 2, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 2, 1, 2, 0, 2, 0, 1, 2, 2, 0, 2, 2, 1, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, 0, 2, 0, 1, 1, 2, 0, 0, 0, 0, 1, 0, 2, 1, 0, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 1, 2, 2, 2, 0, 0, 1, 0, 1, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 1, 0, 2, 0, 2, 0, 2, 0, 0, 1, 1, 1, 0, 0, 2, 0, 1, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 1, 0, 2, 0, 0, 0, 2, 2, 2, 2, 0, 2, 0, 0, 1, 2, 1, 0, 2, 1, 2, 1, 1, 1, 1, 2, 2, 0, 0, 2, 1, 2, 0, 1, 0, 1, 0, 0, 2, 1, 0, 1, 0, 2, 0, 2, 0, 2, 2, 1, 2, 2, 0, 0, 1, 2, 0, 2, 0, 0, 0, 2, 0, 2, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0, 1, 2, 0, 0, 1, 2, 0, 0, 2, 2, 2, 0, 2, 0, 2, 2, 0, 1, 2, 0, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 0, 1, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 0, 0, 0, 1, 0, 2, 2, 2, 0, 0, 0, 0, 2, 0, 1, 0, 2, 2, 0, 0, 2, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 2, 0, 2, 2, 1, 1, 0, 2, 1, 2, 0, 1, 0, 0, 0, 0, 2, 1, 1, 0, 2, 0, 0, 2, 0, 2, 1, 0, 1, 0, 2, 0, 1, 2, 1, 0, 1, 1, 2, 0, 2, 1, 2, 0, 1, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 1, 1, 0, 0, 1, 1, 2, 0, 2, 2, 0, 1, 2, 0, 2, 0, 0, 0, 2, 1, 2, 2, 1, 2, 2, 1, 2, 1, 0, 2, 2, 2, 1, 0, 0, 2, 2, 0, 2, 2, 0, 2, 1, 2, 1, 2, 0, 2, 1, 1, 1, 2, 0, 0, 2, 0, 1, 0, 1, 2, 0, 2, 2, 1, 2, 2, 2, 0, 2, 1, 0, 0, 0, 2, 2, 1, 2, 0, 1, 0, 0, 1, 0, 0, 2, 2, 2, 1, 1, 2, 0, 0, 0, 0, 0, 2, 2, 1, 2, 2, 1, 0, 2, 1, 1, 1, 1, 2, 1, 2, 0, 1, 2, 0, 2, 1, 0, 0, 0, 0, 2, 1, 0, 2, 2, 1, 2, 0, 0, 2, 2, 0, 2, 0, 2, 0, 1, 2, 2, 2, 0, 0, 2, 2, 1, 1, 0, 1, 2, 1, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 0, 1, 0, 1, 2, 0, 0, 0, 1, 0, 2, 2, 0, 1, 0, 2, 2, 0, 2, 0, 2, 0, 1, 0, 0, 1, 1, 0, 2, 1, 1, 1, 2, 2, 2, 0, 0, 1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 1, 0, 2, 1, 2, 1, 2, 0, 2, 0, 1, 0, 2, 0, 1, 0, 1, 0, 0, 1, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 1, 2, 1, 0, 1, 2, 0, 2, 0, 0, 2, 1, 0, 0, 2, 2, 0, 2, 1, 1, 2, 0, 1, 0, 0, 0, 0, 1, 1, 2, 0, 2, 1, 0, 1, 2, 2, 1, 2, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2, 0, 2, 1, 0, 2, 2, 2, 2, 0, 0, 0, 2, 0, 1, 1, 1, 2, 0, 1, 1, 2, 0, 0, 1, 2, 1, 2, 0, 2, 2, 2, 2, 1, 0, 2, 2, 2, 0, 1, 2, 2, 2, 1, 2, 0, 0, 2, 0, 2, 2, 1, 1, 1, 0, 2, 2, 1, 2, 2, 0, 1, 1, 1, 2, 0, 0, 2, 0, 1, 2, 2, 2, 2, 0, 2, 0, 2, 2, 1, 2, 2, 2, 0, 0, 2, 0, 0, 2, 0, 1, 0, 1, 0, 2, 0, 2, 2, 2, 1, 2, 2, 0, 2, 1, 2, 0, 0, 2, 2, 2, 0, 0, 2, 2, 1, 1, 2, 1, 2, 0, 1, 0, 0, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 2, 2, 1, 0, 0, 1, 0, 2, 0, 1, 2, 0, 2, 1, 0, 1, 1, 2, 1, 2, 0, 0, 1, 1, 2, 2, 0, 1, 0, 2, 0, 1, 2, 2, 2, 2, 2, 1, 1, 2, 1, 2, 0, 1, 2, 0, 0, 0]), return_counts = True)[1]
# target_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]), return_counts=True)[1]
# pseudo_label_list = np.unique(np.array([2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 1, 2, 0, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 1, 0, 1, 2, 2, 2, 0, 2, 0, 1, 1, 2, 0, 1, 2, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 1, 2, 0, 2, 0, 0, 2, 1, 1, 2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 2, 1, 1, 0, 0, 2, 0, 0, 2, 1, 1, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0, 0, 2, 0, 2, 2, 0, 2, 2, 1, 0, 0, 0, 0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2]), return_counts=True)[1]
# modified_label_list = np.unique(np.array([0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 2, 0, 1, 1, 0, 0, 1, 1, 1, 0, 2, 2, 1, 2, 2, 2, 0, 1, 1, 2, 1, 1, 0, 2, 0, 0, 2, 1, 1, 2, 1, 0, 2, 2, 2, 2, 1, 2, 0, 2, 2, 1, 1, 1, 0, 1, 0, 0, 2, 1, 1, 2, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, 0, 2, 1, 1, 2, 2, 0, 0, 2, 0, 2, 0, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2]), return_counts=True)[1]

# source_label_list = [369, 213, 301]
# target_label_list = [141, 52, 102]
# pseudo_label_list = [151, 44, 100]
# modified_label_list = [152, 53, 90]

# source_label_list = [358, 206, 318]
# target_label_list = [157, 54, 85]
# pseudo_label_list = [142, 31, 123]
# modified_label_list = [141, 51, 104]

source_label_list = [1685, 535]
target_label_list = [2980, 3934]
pseudo_label_list = [5745, 1169]
# pseudo_label_list = [6211,  703]
modified_label_list = [3800, 3114]

# source_label_list = list(map(lambda x: float(x), source_label_list))
# target_label_list = list(map(lambda x: float(x), target_label_list))
# pseudo_label_list = list(map(lambda x: float(x), pseudo_label_list))
# modified_label_list = list(map(lambda x: float(x), modified_label_list))

# source_label_list /= np.sum(source_label_list)
# target_label_list /= np.sum(target_label_list)
# pseudo_label_list /= np.sum(pseudo_label_list)
# modified_label_list /= np.sum(modified_label_list)

# print(f"source_label_list: {source_label_list}")
# print(f"target_label_list: {target_label_list}")
# print(f"pseudo_label_list: {pseudo_label_list}")
# print(f"modified_label_list: {modified_label_list}")

for i in range(len(source_label_list)):
    if i == 0:
        src_density = np.ones(source_label_list[i]) * i
        tgt_density = np.ones(target_label_list[i]) * i
        pl_density = np.ones(pseudo_label_list[i]) * i
        ml_density = np.ones(modified_label_list[i]) * i
    else:
        src_density = np.concatenate((src_density, np.ones(source_label_list[i]) * i))
        tgt_density = np.concatenate((tgt_density, np.ones(target_label_list[i]) * i))
        pl_density = np.concatenate((pl_density, np.ones(pseudo_label_list[i]) * i))
        ml_density = np.concatenate((ml_density, np.ones(modified_label_list[i]) * i))
classes = np.arange(2)

# colors = ['#ff8c00', '#009905', '#0077ff', '#0077ff'] 
colors2 = ['#EA3D5F', '#F6C84A', '#5DCA76', '#4398D8']
# colors3 = ['#E7298A', '#1B9E77', '#7570B3', '#0077ff']
names = ['Source Label Distribution', 'Target Label Distribution', 'Pseudo Label Distribution', 'Label Distribution Handler (Ours)']
width = 0.26  # the width of the bars
fig, axes = plt.subplots(1, 4, figsize=(48, 8.5))
distributions = [source_label_list, target_label_list, pseudo_label_list, modified_label_list]
densities = [src_density, tgt_density, pl_density, ml_density]

titles = ['(e) Source Label Distribution', '(f) Target Label Distribution', '(g) Pseudo Label Distribution', '(h) Label Distribution Handler (Ours)']

for i, (dist, dens) in enumerate(zip(distributions, densities)):
    ax = axes[i]
    for axis in ['top','bottom','left','right']:
        ax.spines[axis].set_linewidth(2)

    # ax.hist(dens, range(len(source_label_list) + 1), color=colors2[i], density=True, alpha=0.68, rwidth=0.85, align='left', label=names[i])
    # sns.kdeplot(dens, ax=ax, color=colors2[i], alpha=0.28, bw_adjust=2.5, fill=True, linewidth=0.2)
    ax.hist(dens, range(len(source_label_list) + 1), color=colors2[i], density=True, alpha=0.5, rwidth=0.85, align='left', label=names[i])
    sns.kdeplot(dens, ax=ax, color=colors2[i], alpha=0.28, bw_adjust=6, fill=True, linewidth=0.2)
    ax.set_ylabel('Ratio', fontsize=38)
    ax.set_xlabel('Label', fontsize=38)
    ax.set_xticks(range(len(source_label_list)))
    ax.set_title(titles[i], y=1.03, fontsize=42)
    # ax.set_ylim(0, 0.6)
    ax.set_ylim(0, 0.9)
    ax.tick_params(labelsize=38)


# # add cls-wise conf.    
# g = open('wandb_shapetomodel_clswiseconf.csv', 'r', encoding='utf-8')
# rdr = csv.reader(g)
# cls_conf_2 = [[],[], [],[],[],[],[],[],[],[]]
# for line in rdr:
#     if 'Cls' in line[1]:
#         cls_conf_2[int(line[1][-1])].append(float(line[2]))

# x_epoch = list(range(1,151))
# ax = axes[3]
# ax.set_title("(d) Class-wise Confidence \n for Intra-class Data",y=-0.29, fontsize=35)
# ax.set_ylabel('Confidence',fontsize=26)
# ax.set_xlabel(r'Epoch',fontsize=29)
# ax.tick_params(labelsize=22)
# ax.set_xlim([0,155])
# ax.grid(True, linewidth=0.5)

# colors = ['#cde3f6', '#9bc7ec', '#69abe3', '#378fd9', '#2271b3', '#f6dfcd', '#ecbf9b', '#e3a069', '#d98037', '#b36322']
# colors = ['black', '#b36322', '#d98037', 'black', '#2271b3', 'black', 'black', '#e3a069', '#378fd9', '#69abe3']

# cls_order =[4,8,9, 1,2,7]
# for i in cls_order:
#     if colors[i] == 'black':
#         continue
#     if i in [4,8,9]:
#         cls = 'major'
#     else:
#         cls = 'minor'
#     ax.plot(x_epoch, cls_conf_2[i], linestyle='-', linewidth=2.5, color=colors[i], label=f'{cls} class (Class {i})')
# ax.legend(loc='lower right',fontsize=19,numpoints=1)

plt.show()
# plt.savefig(f'{source}_to_{target}_remark3.3.pdf', facecolor=fig.get_facecolor(), bbox_inches='tight', format='pdf',pad_inches=0.1, dpi=600)


# In[4]:


with open("optdigits.pickle", "rb") as f:
    optdigits_entropy_list = pickle.load(f)

with open("cmc_ent.pickle", "rb") as f:
    cmc_entropy_list = pickle.load(f)

print(f"optdigits_entropy_list: {optdigits_entropy_list}")
print(f"cmc_entropy_list: {cmc_entropy_list}")

plt.clf()
plt.figure(figsize=(8, 6))
plt.hist(np.array(cmc_entropy_list), bins=20, color="#FFC61E", edgecolor='black')

plt.title("(a) Target Domain Entropy Distribution (CMC)", fontsize=16)
plt.xlim([0, 1])
plt.xlabel("Entropy", fontsize=12)
plt.ylabel("Number of Instances", fontsize=12)
plt.tick_params(labelsize=12)
plt.show()

plt.clf()
plt.figure(figsize=(8, 6))
plt.hist(np.array(optdigits_entropy_list), bins=15, color="#FFC61E", edgecolor='black')

plt.title("(b) Target Domain Entropy Distribution (Optdigits)", fontsize=16)
plt.xlim([0, 1])
plt.xlabel("Entropy", fontsize=12)
plt.ylabel("Number of Instances", fontsize=12)
plt.tick_params(labelsize=12)
plt.show()


# In[ ]:


import pandas as pd
import pickle

with open(file="cmc_tsne.pickle", mode='rb') as f:
    z = pickle.load(f)

with open(file="cmc_tsne_cls.pickle", mode='rb') as g:
    cls = pickle.load(g)

plt.clf()
plt.figure(figsize=(8, 6))
plt.gca().set_aspect('equal')
df = pd.DataFrame()
df["y"] = cls
df["d1"] = z[:, 0]
df["d2"] = z[:, 1]
plt.clf()
sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df)



plt.xlabel(None)
plt.ylabel(None)
plt.xticks([])
plt.yticks([])
plt.title("(c) Latent Space Visualization (CMC)", fontsize=16)
plt.show()


with open(file="optdigits_tsne.pickle", mode='rb') as f:
    z = pickle.load(f)

with open(file="optdigits_tsne_cls.pickle", mode='rb') as g:
    cls = pickle.load(g)


plt.clf()
plt.figure(figsize=(8, 6))
plt.gca().set_aspect('equal')
df = pd.DataFrame()
df["y"] = cls
df["d1"] = z[:, 0]
df["d2"] = z[:, 1]
plt.clf()
sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df)

plt.xlabel(None)
plt.ylabel(None)
plt.xticks([])
plt.yticks([])
plt.title("(d) Latent Space Visualization (Optdigits)", fontsize=16)
plt.show()


# In[5]:


fig, axes = plt.subplots(1, 4, figsize=(48, 8.5))


ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

ax.hist(np.array(cmc_entropy_list), bins=20, color="#FFC61E", edgecolor='black', linewidth=2)
ax.set_xlim(0, 1)
ax.set_ylabel('Number of Insances', fontsize=36)
ax.set_xlabel('Entropy', fontsize=36)
ax.set_xticks(range(len(source_label_list)))
ax.set_title("(a) Target Domain Entropy Distribution (CMC)", y=1.03, fontsize=36)
ax.tick_params(labelsize=36)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

ax.hist(np.array(optdigits_entropy_list), bins=20, color="#FFC61E", edgecolor='black', linewidth=2)
ax.set_xlim(0, 1)
ax.set_ylabel('Number of Insances', fontsize=36)
ax.set_xlabel('Entropy', fontsize=36)
ax.set_xticks(range(len(source_label_list)))
ax.set_title("(b) Target Domain Entropy Distribution (Optdigits)", y=1.03, fontsize=36)
ax.tick_params(labelsize=36)




ax = axes[2]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="cmc_tsne.pickle", mode='rb') as f:
    z = pickle.load(f)

with open(file="cmc_tsne_cls.pickle", mode='rb') as g:
    cls = pickle.load(g)

# plt.clf()
# plt.figure(figsize=(8, 6))
# ax.gca().set_aspect('equal')
df = pd.DataFrame()
df["y"] = cls
df["d1"] = z[:, 0]
df["d2"] = z[:, 1]
# plt.clf()
sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax, s=200)

ax.set_xlabel(None)
ax.set_ylabel(None)
ax.set_xticks([])
ax.set_yticks([])
ax.set_title("(c) Latent Space Visualization (CMC)", y=1.03, fontsize=36)




ax = axes[3]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="optdigits_tsne.pickle", mode='rb') as f:
    z = pickle.load(f)

with open(file="optdigits_tsne_cls.pickle", mode='rb') as g:
    cls = pickle.load(g)

# plt.clf()
# plt.figure(figsize=(8, 6))
# ax.gca().set_aspect('equal')
df = pd.DataFrame()
df["y"] = cls
df["d1"] = z[:, 0]
df["d2"] = z[:, 1]
# plt.clf()
sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax, s=200)
# ax.scatter(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax)

ax.set_xlabel(None)
ax.set_ylabel(None)
ax.set_xticks([])
ax.set_yticks([])
ax.set_title("(d) Latent Space Visualization (Optdigits)", y=1.03, fontsize=36)


# In[2]:


import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np
import csv

fig, axes = plt.subplots(1, 2, figsize=(22, 8.5 * 4 / 3))

ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)


# with open(file="cmc_tsne.pickle", mode='rb') as f:
#     z = pickle.load(f)

# with open(file="cmc_tsne_cls.pickle", mode='rb') as g:
#     cls = pickle.load(g)


with open(file="cmc_entropy_list.pickle", mode='rb') as f:
    entropy_list = pickle.load(f)

with open(file="cmc_gradient_list.pickle", mode='rb') as f:
    gradient_list = pickle.load(f)

print(f"entropy_list: {entropy_list}")
print(f"gradient_list: {gradient_list}")

ax.scatter(gradient_list, entropy_list, color="#009ADE")
ax.set_xlabel('Gradient Norm', fontsize=36)
ax.set_ylabel('Entropy', fontsize=36)
ax.set_title("Gradient Norm vs. Entropy", fontsize=36, y=1.03)

ax.axhline(y=0.4, color='k', linestyle='--', linewidth=2)

ax.tick_params(fontsize=36)



# ax = axes[1]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# with open(file="cmc_ent.pickle", mode='rb') as f:
#     entropy_list = list(pickle.load(f))

# with open(file="cmc_conf.pickle", mode='rb') as f:
#     conf_list = list(pickle.load(f))

# ax.scatter(conf_list, entropy_list, color="#009ADE")
# ax.set_xlabel('Confidence', fontsize=36)
# ax.set_ylabel('Entropy', fontsize=36)
# ax.set_title("Confidence vs. Entropy", fontsize=36, y=1.03)
# ax.tick_params(fontsize=36)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="calibration_bns.pickle", mode='rb') as f:
    bns = list(pickle.load(f))
with open(file="calibration_y.pickle", mode='rb') as f:
    y = list(pickle.load(f))

# plt.figure(figsize=(10, 8))  # width:20, height:3
ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.set_xlabel('Confidence', fontsize=36)
ax.set_ylabel('Accuracy', fontsize1=36)
ax.set_title("Reliability Diagram", fontsize=36, y=1.03)
ax.tick_params(fontsize=36)


# %%
import pandas as pd


plt.title("")

fig, axes = plt.subplots(1, 3, figsize=(34.5, 8.5))



ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="calibration_bns_cmc_before.pickle", mode='rb') as f:
    bns = list(pickle.load(f))
with open(file="calibration_y_cmc_before.pickle", mode='rb') as f:
    y = list(pickle.load(f))

print(f"bns: {bns}")
print(f"y: {y}")

# plt.figure(figsize=(10, 8))  # width:20, height:3
ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.set_xlabel('Confidence', fontsize=36)
ax.set_ylabel('Accuracy', fontsize=36)
ax.set_title("Reliability Diagram\nBefore Calibration", fontsize=42, y=1.03)
ax.tick_params(labelsize=36)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="calibration_bns_cmc_after.pickle", mode='rb') as f:
    bns = list(pickle.load(f))
with open(file="calibration_y_cmc_after.pickle", mode='rb') as f:
    y = list(pickle.load(f))


# plt.figure(figsize=(10, 8))  # width:20, height:3
ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.set_xlabel('Confidence', fontsize=36)
ax.set_ylabel('Accuracy', fontsize=36)
ax.set_title("Reliability Diagram\nAfter Calibration", fontsize=42, y=1.03)
ax.tick_params(labelsize=36)


ax = axes[2]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="cmc_tsne.pickle", mode='rb') as f:
    z = pickle.load(f)

with open(file="cmc_tsne_cls.pickle", mode='rb') as g:
    cls = pickle.load(g)

df = pd.DataFrame()
df["y"] = cls
df["d1"] = z[:, 0]
df["d2"] = z[:, 1]
sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax, s=200)

ax.set_xlabel(None)
ax.set_ylabel(None)
ax.set_xticks([])
ax.set_yticks([])
ax.set_title("(c) Latent Space Visualization\n(CMC)", y=1.03, fontsize=42)


# In[28]:


import pandas as pd


from sklearn import datasets, linear_model


fig, axes = plt.subplots(1, 3, figsize=(34.5, 8.5))

ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="pickle/cmc_MLP_0_grad_norm.pickle", mode='rb') as f:
    gradient_norm = list(pickle.load(f))
with open(file="pickle/cmc_MLP_0_smoothness.pickle", mode='rb') as f:
    smoothness = list(pickle.load(f))

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
# ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)

x = np.log(np.array(gradient_norm))
y = np.log(np.array(smoothness))

print(f"x: {x}")
print(f"y: {y}")

ax.scatter(x, y)

print(np.polyfit(x, y, deg=1))

# regr = linear_model.LinearRegression(fit_intercept=True)

# regr.fit(x.reshape(-1, 1), y.reshape(-1, 1))
# The coefficients
# print("Coefficients: \n", regr.coef_)

ax.set_xlabel('log(gradient norm)', fontsize=36)
ax.set_ylabel('log(smoothness)', fontsize=36)
ax.set_title("(a) cmc", fontsize=42, y=1.03)
ax.tick_params(labelsize=36)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="pickle/dna_MLP_0_grad_norm.pickle", mode='rb') as f:
    gradient_norm = list(pickle.load(f))
with open(file="pickle/dna_MLP_0_smoothness.pickle", mode='rb') as f:
    smoothness = list(pickle.load(f))

x = np.log(np.array(gradient_norm))
y = np.log(np.array(smoothness))

ax.scatter(x, y)

print(np.polyfit(x, y, deg=1))

ax.set_xlabel('log(gradient norm)', fontsize=36)
ax.set_ylabel('log(smoothness)', fontsize=36)
ax.set_title("(b) dna", fontsize=42, y=1.03)
ax.tick_params(labelsize=36)



# fig = plt.figure()
fig.suptitle("Gradient Norm vs. Local Gradient Lipschitz Contstant", fontsize=48, y=1.06)

# # plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
# ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
# ax.set_xlabel('Confidence', fontsize=36)
# ax.set_ylabel('Accuracy', fontsize=36)
# ax.set_title("Reliability Diagram\nAfter Calibration", fontsize=42, y=1.03)
# ax.tick_params(labelsize=36)


# ax = axes[1]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# ax.hist(np.array(optdigits_entropy_list), bins=20, color="#FFC61E", edgecolor='black', linewidth=2)
# ax.set_xlim(0, 1)
# ax.set_ylabel('Number of Insances', fontsize=36)
# ax.set_xlabel('Entropy', fontsize=36)
# ax.set_xticks(range(len(source_label_list)))
# ax.set_title("(b) Target Domain Entropy Distribution (Optdigits)", y=1.03, fontsize=36)
# ax.tick_params(fontsize=36)




# ax = axes[2]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# with open(file="cmc_tsne.pickle", mode='rb') as f:
#     z = pickle.load(f)

# with open(file="cmc_tsne_cls.pickle", mode='rb') as g:
#     cls = pickle.load(g)

# # plt.clf()
# # plt.figure(figsize=(8, 6))
# # ax.gca().set_aspect('equal')
# df = pd.DataFrame()
# df["y"] = cls
# df["d1"] = z[:, 0]
# df["d2"] = z[:, 1]
# # plt.clf()
# sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax, s=200)

# ax.set_xlabel(None)
# ax.set_ylabel(None)
# ax.set_xticks([])
# ax.set_yticks([])
# ax.set_title("(c) Latent Space Visualization\n(CMC)", y=1.03, fontsize=42)


ax = axes[2]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

with open(file="pickle/mfeat-pixel_MLP_0_grad_norm.pickle", mode='rb') as f:
    gradient_norm = list(pickle.load(f))
with open(file="pickle/mfeat-pixel_MLP_0_smoothness.pickle", mode='rb') as f:
    smoothness = list(pickle.load(f))

x = np.log(np.array(gradient_norm))
y = np.log(np.array(smoothness))

ax.scatter(x, y)

print(np.polyfit(x, y, deg=1))

ax.set_xlabel('log(gradient norm)', fontsize=36)
ax.set_ylabel('log(smoothness)', fontsize=36)
ax.set_title("(c) mfeat-pixel", fontsize=42, y=1.03)
ax.tick_params(labelsize=36)



# ax = axes[3]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# with open(file="optdigits_tsne.pickle", mode='rb') as f:
#     z = pickle.load(f)

# with open(file="optdigits_tsne_cls.pickle", mode='rb') as g:
#     cls = pickle.load(g)

# # plt.clf()
# # plt.figure(figsize=(8, 6))
# # ax.gca().set_aspect('equal')
# df = pd.DataFrame()
# df["y"] = cls
# df["d1"] = z[:, 0]
# df["d2"] = z[:, 1]
# # plt.clf()
# sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax, s=200)
# # ax.scatter(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette('husl', cls.max() + 1), data=df, ax=ax)

# ax.set_xlabel(None)
# ax.set_ylabel(None)
# ax.set_xticks([])
# ax.set_yticks([])
# ax.set_title("(d) Latent Space Visualization\n(Optdigits)", y=1.03, fontsize=42)


# In[2]:


import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np
import csv
import pandas as pd

fig, axes = plt.subplots(1, 5, figsize=(40, 8), constrained_layout=True)

dataset_list = ['(a) cmc', '(b) heloc', '(c) adult', '(d) mfeat-pixel', '(e) mnist']
for i in range(5):
    # ax = axes[i//3, i%3]
    ax = axes[i]
    for axis in ['top','bottom','left','right']:
        ax.spines[axis].set_linewidth(2)

    dataset = dataset_list[i]
    dataset_name = dataset.split(")")[-1].strip()

    with open(file=f"pickle/{dataset_name}_MLP_0_grad_norm.pickle", mode='rb') as f:
        gradient_norm = list(pickle.load(f))
    with open(file=f"pickle/{dataset_name}_MLP_0_smoothness.pickle", mode='rb') as f:
        smoothness = list(pickle.load(f))
    x = np.log(np.array(gradient_norm))
    y = np.log(np.array(smoothness))

    ax.scatter(x, y)

    # print(np.polyfit(x, y, deg=1))
    ax.set_xlabel('log(gradient norm)', fontsize=36)
    ax.set_ylabel('log(smoothness)', fontsize=36)
    ax.set_title(dataset, fontsize=40, y=1.03)
    ax.tick_params(labelsize=28)

    # with open(f'gradient_deviation_{dataset}.pickle', 'rb') as f:
    #     gradient_list = pickle.load(f)

    # ax.scatter(list(range(len(gradient_list))), gradient_list, s=4.0)
    # ax.set_xlabel("Iterations", fontsize=36)
    # ax.set_ylabel("Gradient Deviation", fontsize=36)
    # ax.set_title(dataset, fontsize=40, y=1.03)
    # # ax.legend(loc='best', fontsize=28)
    # ax.tick_params(labelsize=28)
fig.suptitle("Gradient Norm vs. Local Gradient Lipschitz Contstant", fontsize=42, y=1.08)


# %%
# TODO: entropy distribution!
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import csv
import pandas as pd

dataset_list = ["heloc", "anes", "diabetes_readmission", "nhanes_lead", "optdigits", "dna"]
dataset_official_list = ["HELOC", "Voting", "Hospital Readmission", "Childhood Lead", "Optdigits", "DNA"]
model_list = ["MLP", "AutoInt", "ResNet", "FTTransformer"]
model_official_list = ["MLP", "AutoInt", "ResNet", "FT-Transformer"]

fontsize = 68
titlesize = 80

fig, axes = plt.subplots(len(dataset_list), len(model_list), figsize=(24 * len(model_list), 18 * len(dataset_list)))
plt.subplots_adjust(top=0.99, bottom=0.01, hspace=0.35, wspace=0.3)

for i, dataset in enumerate(dataset_list):
    for j, model in enumerate(model_list):
        try:
            with open(f"../pickle/{dataset}_{model}_0_ent.pickle", "rb") as f:
                entropy_list = pickle.load(f)
        except Exception as e:
            print(e)
            continue

        ax = axes[i][j]
        for axis in ['top','bottom','left','right']:
            ax.spines[axis].set_linewidth(4)
        ax.xaxis.set_label_coords(0, -1e-2)

        ax.hist(np.array(entropy_list), bins=20, color="#FFA500", edgecolor='black', linewidth=2)


        ax.set_xticks([0, 0.2, 0.4, 0.6, 0.8, 1.0], ['0', '0.2', '0.4', '0.6', '0.8', '1'])
        # ax.set_xlim(0, 1)
        ax.set_ylabel('Number of Instances', fontsize=fontsize)
        ax.set_xlabel('Entropy', fontsize=fontsize, y=-.075)
        # ax.set_xticks(range(len(source_label_list)))
        ax.set_title(f"Entropy Distribution\n({dataset_official_list[i]}, {model_official_list[j]})", y=1.03, fontsize=titlesize)
        ax.tick_params(labelsize=fontsize)

# plt.savefig("further_entropy_distribution.png", dpi=100)


# In[14]:

# %%
# TODO: latent space visualization
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import csv
import pandas as pd

# dataset_list = ["heloc", "anes", "diabetes_readmission", "mimic_extract_mort_hosp", "nhanes_lead", "brfss_diabetes"]
dataset_list = ["heloc", "anes", "diabetes_readmission", "nhanes_lead", "optdigits", "dna"]
dataset_official_list = ["HELOC", "Voting", "Hospital Readmission", "Childhood Lead", "Optdigits", "DNA"]
model_list = ["MLP", "AutoInt", "ResNet", "FTTransformer"]
model_official_list = ["MLP", "AutoInt", "ResNet", "FT-Transformer"]

# dataset_list = ["heloc", "anes", "diabetes_readmission", "cmc", "mfeat-pixel", "dna"]
# model_list = ["MLP", "TabNet", "FTTransformer"]
titlesize = 68

fig, axes = plt.subplots(len(dataset_list), len(model_list), figsize=(21 * len(model_list), 16 * len(dataset_list)))
plt.subplots_adjust(top=0.99, bottom=0.01, hspace=0.2, wspace=0.25)

for i, dataset in enumerate(dataset_list):
    for j, model in enumerate(model_list):
        try:
            with open(file=f"../pickle/{dataset}_{model}_0_tsne.pickle", mode='rb') as f:
                z = pickle.load(f)
            with open(file=f"../pickle/{dataset}_{model}_0_tsne_cls.pickle", mode='rb') as g:
                cls = pickle.load(g)
        except Exception as e:
            print(e)
            continue

        ax = axes[i][j]
        for axis in ['top','bottom','left','right']:
            ax.spines[axis].set_linewidth(4)
        ax.xaxis.set_label_coords(0, -1e-2)

        colors = ["#F24141", "#1871DE", "#525252", "#FFA500", "#008001", "#75380A", "#800080", '#008080', '#FFD700', '#FF69B4']
        sns.set_palette(sns.color_palette(colors))

        df = pd.DataFrame()
        df["y"] = cls
        df["d1"] = z[:, 0]
        df["d2"] = z[:, 1]
        # plt.clf()
        pl = sns.scatterplot(x="d1", y="d2", hue=df.y.tolist(), palette=sns.color_palette(None), data=df, ax=ax, s=200, edgecolor='black')

        ax.set_xlabel(None)
        ax.set_ylabel(None)
        ax.set_xticks([])
        ax.set_yticks([])
        ax.get_legend().set_visible(False)
        ax.set_title(f"Latent Space Visualization\n({dataset_official_list[i]}, {model_official_list[j]})", y=1.03, fontsize=titlesize)

# plt.savefig("further_latent_visualization.png", dpi=100)

# %%
# TODO: calibration!
import pickle
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import csv
import pandas as pd

dataset_list = ["heloc", "anes", "diabetes_readmission", "mimic_extract_mort_hosp", "nhanes_lead", "brfss_diabetes"]
dataset_official_list = ["HELOC", "Voting", "Hospital Readmission", "ICU Mortality", "Childhood Lead", "Diabetes"]
model_list = ["MLP", "AutoInt", "ResNet", "FTTransformer"]
model_official_list = ["MLP", "AutoInt", "ResNet", "FT-Transformer"]
titlesize = 68
fontsize = 60
legendsize = 52

fig, axes = plt.subplots(len(dataset_list), len(model_list), figsize=(20 * len(model_list), 12 * len(dataset_list)))
plt.subplots_adjust(top=0.99, bottom=0.01, hspace=0.2, wspace=0.35)

for i, dataset in enumerate(dataset_list):
    for j, model in enumerate(model_list):
        try:
            with open(file=f"../pickle/calibration_bns_{dataset}_{model}_0.pickle", mode='rb') as f:
                bns = list(pickle.load(f))
            with open(file=f"../pickle/calibration_y_{dataset}_{model}_0.pickle", mode='rb') as f:
                y = list(pickle.load(f))
        except Exception as e:
            print(e)
            continue

        ax = axes[i][j]
        for axis in ['top','bottom','left','right']:
            ax.spines[axis].set_linewidth(4)
        ax.xaxis.set_label_coords(0, -1e-2)

        ax.set_facecolor('white')
        for spine in ax.spines.values():
            spine.set_visible(True)
            spine.set_linewidth(4)
            spine.set_edgecolor('black')
        ax.grid(True, which='both', axis='both', linestyle='--', linewidth=1.5, color='gray')

        ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
        ax.bar(bns, bns, align='edge', width=0.1, color='#525252', alpha=0.7, label='Expected', edgecolor='black', linewidth=2, hatch='//')
        ax.bar(bns, y, align='edge', width=0.1, color='#F24141', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
        # ax.set_title(f"Reliability Diagram\n({dataset_official_list[i]}, {model_official_list[j]})", fontsize=titlesize, y=1.03)
        # ax.set_xlabel('Confidence', fontsize=fontsize, y=-0.1)
        ax.set_xlabel('Confidence', fontsize=fontsize, y=-0.1)
        ax.set_ylabel('Accuracy', fontsize=fontsize)
        ax.set_xticks([0.00, 0.25, 0.50, 0.75, 1.00], ['0.00', '0.25', '0.50', '0.75', '1.00'])
        ax.legend(loc='upper left', fontsize=legendsize, facecolor="#eeeef4")

        ax.tick_params(labelsize=fontsize)

# plt.savefig("further_reliability_diagram.png", dpi=100)


# In[5]:
# TODO: label distribution
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np

dataset_list = ["heloc", "anes", "diabetes_readmission", "mimic_extract_mort_hosp", "nhanes_lead", "brfss_diabetes"]
dataset_official_list = ["HELOC", "Voting", "Hospital Readmission", "ICU Mortality", "Childhood Lead", "Diabetes"]
# model_list = ["MLP"]
# model_official_list = ["MLP"]
model = "MLP"
model_official = "MLP"
titlesize = 68
fontsize = 60
legendsize = 52

fig, axes = plt.subplots(len(dataset_list), 4, figsize=(54, 10 * len(dataset_list)))
plt.subplots_adjust(top=0.99, bottom=0.01, hspace=0.5, wspace=0.3)

for i in range(len(dataset_list)):
    dataset = dataset_list[i]

    try:
        with open(f"../pickle/{dataset}_{model}_0_Source Label Distribution_label_distribution.pickle", "rb") as f:
            src_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_Target Label Distribution_label_distribution.pickle", "rb") as f:
            tgt_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_Pseudo Label Distribution_label_distribution.pickle", "rb") as f:
            pl_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_AdapTable Label Distribution_label_distribution.pickle", "rb") as f:
            ml_density = pickle.load(f)


        source_density = np.bincount(src_density) / len(src_density)
        target_density = np.bincount(tgt_density) / len(tgt_density)
        pseudo_density = np.bincount(pl_density) / len(pl_density)
        print(f"{len(pseudo_density)=}")

        if len(pseudo_density) == 1:
            pseudo_density = np.concatenate([pseudo_density, [0]])
        modified_density = np.bincount(ml_density) / len(ml_density)

        source_label_list = np.bincount(src_density) / len(src_density)
        target_label_list = np.bincount(tgt_density) / len(tgt_density)
        pseudo_label_list = np.bincount(pl_density) / len(pl_density)
        modified_label_list = np.bincount(ml_density) / len(ml_density)

    except Exception as e:
        print(f"{e=}")
        continue

    print(f"{source_label_list=}")

    # source_label_list = [1685, 535]
    # target_label_list = [2980, 3934]
    # pseudo_label_list = [5745, 1169]
    # modified_label_list = [3800, 3114]
    # for i in range(len(source_label_list)):
    #     if i == 0:
    #         src_density = np.ones(source_label_list[i]) * i
    #         tgt_density = np.ones(target_label_list[i]) * i
    #         pl_density = np.ones(pseudo_label_list[i]) * i
    #         ml_density = np.ones(modified_label_list[i]) * i
    #     else:
    #         src_density = np.concatenate((src_density, np.ones(source_label_list[i]) * i))
    #         tgt_density = np.concatenate((tgt_density, np.ones(target_label_list[i]) * i))
    #         pl_density = np.concatenate((pl_density, np.ones(pseudo_label_list[i]) * i))
    #         ml_density = np.concatenate((ml_density, np.ones(modified_label_list[i]) * i))
    #     print(f"{src_density=}")
    # classes = np.arange(np.unique(src_density))
    unique_values = np.unique(src_density)  # Get unique values from src_density
    classes = np.arange(len(unique_values))  # Create an array of indices from 0 to the number of unique values


    colors2 = ["#FFA500", "#1871DE", "#525252", "#F24141"]
    names = ['Source Label Distribution', 'Target Label Distribution', 'Pseudo Label Distribution', 'Label Distribution Handler (Ours)']
    width = 0.26  # the width of the bars

    distributions = [source_label_list, target_label_list, pseudo_label_list, modified_label_list]
    densities = [src_density, tgt_density, pl_density, ml_density]

    titles = ['(a) Source Label Distribution', '(b) Target Label Distribution', '(c) Pseudo Label Distribution', '(d) Label Distribution Handler (Ours)']

    for j, (dist, dens) in enumerate(zip(distributions, densities)):
        ax = axes[i][j]
        for axis in ['top','bottom','left','right']:
            ax.spines[axis].set_linewidth(4)
        ax.xaxis.set_label_coords(0, -1e-2)

        ax.hist(dens, bins=2, color=colors2[j], density=True, alpha=1, rwidth=.7, align='mid', label=names[j], edgecolor='black', linewidth=3)
        sns.kdeplot(dens, ax=ax, color='gray', alpha=.2, bw_adjust=7, fill=True, edgecolor='black', linewidth=0)

        ax.set_ylabel('Ratio', fontsize=38)
        ax.set_xlabel('Label', fontsize=38, y=-0.1)
        ax.set_xticks(range(len(source_label_list)))
        ax.set_title(f"{titles[j]}\n({dataset_official_list[i]})", y=1.03, fontsize=42)
        ax.set_ylim(0, 1.1)
        ax.tick_params(labelsize=38)

plt.show()


# In[3]:


import matplotlib

source_acc = 0.4763

smoothing_factor_list = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]
smoothing_factor_values = [0.6371, 0.6374, 0.6338, 0.6244, 0.6198, 0.6105, 0.6008, 0.5949, 0.5843, 0.5785, 0.6186]
# smoothing_factor_values = [0.6371, 0.6374, 0.6338, 0.6244, 0.6198, 0.6105, 0.6008, 0.5949, 0.5843, 0.5785]
# smoothing_factor_values = [0.6371, 0.6374, 0.6338, 0.6244, 0.6198, 0.6105, 0.6008, 0.5949, 0.5843, 0.5785]

lqt_list = [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5]
lqt_values = [0.6371, 0.6373, 0.637, 0.6367, 0.6368, 0.6374, 0.6371, 0.6367, 0.6362, 0.6347, 0.6329]

hqt_list = [0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1]
hqt_values = [0.6535, 0.6458, 0.6423, 0.6393, 0.6375, 0.6374, 0.6374, 0.6374, 0.6371, 0.6371, 0.6371]

# import pandas as pd
fig, axes = plt.subplots(1, 3, figsize=(52, 12))
ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

colors2 = ['#EA3D5F', '#F6C84A', '#5DCA76', '#4398D8']

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.plot(smoothing_factor_list, smoothing_factor_values, color=colors2[3], linestyle='-', marker='o', linewidth=5, markersize=15, label="Ours")

ax.axhline(y=source_acc, color=colors2[0], linestyle='--', linewidth=5, label="Unadapted")

ax.grid(linestyle='--', linewidth=1)

# ax.plot(smoothing_factor_list, smoothing_factor_values, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.set_xlabel('Smoothing Factor ' + r"$\alpha$", fontsize=48)
ax.set_ylabel('Accuracy', fontsize=48)
ax.set_title("Sensitivity to " + r"$\alpha$", fontsize=60, y=1.03)

ax.legend(fontsize=48, loc='lower right')
ax.tick_params(labelsize=48)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.plot(lqt_list, lqt_values, color=colors2[3], linestyle='-', marker='o', linewidth=5, markersize=15, label="Ours")


# ax.plot(smoothing_factor_list, smoothing_factor_values, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.axhline(y=source_acc, color=colors2[0], linestyle='--', linewidth=5, label="Unadapted")

ax.grid(linestyle='--', linewidth=1)

ax.set_xlabel('Low Quantile ' + r"$q_{\mathrm{low}}$", fontsize=48)
ax.set_ylabel('Accuracy', fontsize=48)
ax.set_title("Sensitivity to " + r"$q_{\mathrm{low}}$", fontsize=60, y=1.03)
TODO
ax.legend(fontsize=48, loc='lower right')
ax.tick_params(labelsize=48)
# ax = axes[1]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# with open(file="calibration_bns_cmc_after.pickle", mode='rb') as f:
#     bns = list(pickle.load(f))
# with open(file="calibration_y_cmc_after.pickle", mode='rb') as f:
#     y = list(pickle.load(f))

# print(f"bns: {bns}")
# print(f"y: {y}")

# # plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
# ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
# ax.set_xlabel('Confidence', fontsize=36)
# ax.set_ylabel('Accuracy', fontsize=36)
# ax.set_title("Reliability Diagram\nAfter Calibration", fontsize=42, y=1.03)
# ax.tick_params(labelsize=36)



ax = axes[2]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.plot(hqt_list, hqt_values, color=colors2[3], linestyle='-', marker='o', linewidth=5, markersize=15, label="Ours")


# ax.plot(smoothing_factor_list, smoothing_factor_values, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.axhline(y=source_acc, color=colors2[0], linestyle='--', linewidth=5, label="Unadapted")


ax.grid(linestyle='--', linewidth=1)
# ax.set_xticks([float(v) for v in hqt_list])

ax.set_xlabel('High Quantile ' + r"$q_{\mathrm{high}}$", fontsize=48)
ax.set_ylabel('Accuracy', fontsize=48)
ax.set_title("Sensitivity to " + r"$q_{\mathrm{high}}$", fontsize=60, y=1.03)
# ax.legend(['Ours', 'Unadapted'])
ax.legend(fontsize=48, loc='lower right')
ax.tick_params(labelsize=48)


# In[91]:
import matplotlib

source_acc = 0.4763

lr_list = ['1e-6', '3e-6', '1e-5', '3e-5', '1e-4', '3e-4', '1e-3', '3e-3', '1e-2']
lr_values = [0.476, 0.4757, 0.4734, 0.468, 0.4531, 0.4364, 0.4312, 0.4312, 0.4312]
# smoothing_factor_values = [0.6371, 0.6374, 0.6338, 0.6244, 0.6198, 0.6105, 0.6008, 0.5949, 0.5843, 0.5785]
# smoothing_factor_values = [0.6371, 0.6374, 0.6338, 0.6244, 0.6198, 0.6105, 0.6008, 0.5949, 0.5843, 0.5785]

num_steps_list = ['1', '2', '3', '5', '10', '20', '30']
num_steps_values = [0.4531, 0.4421, 0.4364, 0.4313, 0.4312, 0.4312, 0.4312]

# import pandas as pd
fig, axes = plt.subplots(1, 2, figsize=(34, 12))
ax = axes[0]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

colors2 = ['#EA3D5F', '#F6C84A', '#5DCA76', '#4398D8']

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.plot(lr_list, lr_values, color=colors2[3], linestyle='-', marker='o', linewidth=5, markersize=15, label="Tent")

ax.axhline(y=source_acc, color=colors2[0], linestyle='--', linewidth=5, label="Unadapted")

ax.grid(linestyle='--', linewidth=1)

# ax.plot(smoothing_factor_list, smoothing_factor_values, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
# ax.set_xticks(lr_list)

# ax.set_xticks(list(range(lr_list)), lr_list, fontsize=36)

ax.set_xlabel('Learning Rate ' + r"$\gamma$", fontsize=48)
ax.set_ylabel('Accuracy', fontsize=48)
ax.set_title("Sensitivity to " + r"$\gamma$", fontsize=60, y=1.03)

ax.legend(fontsize=48, loc='upper right')
ax.tick_params('x', labelsize=40)
ax.tick_params('y', labelsize=48)


ax = axes[1]
for axis in ['top','bottom','left','right']:
    ax.spines[axis].set_linewidth(2)

# plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
ax.plot(num_steps_list, num_steps_values, color=colors2[3], linestyle='-', marker='o', linewidth=5, markersize=15, label="Tent")


# ax.plot(smoothing_factor_list, smoothing_factor_values, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
ax.axhline(y=source_acc, color=colors2[0], linestyle='--', linewidth=5, label="Unadapted")

ax.grid(linestyle='--', linewidth=1)

# ax.set_xticks(list(range(num_steps_list)), num_steps_list, fontsize=36)

ax.set_xlabel('Adaptation Steps ' + r"$n$", fontsize=48)
ax.set_ylabel('Accuracy', fontsize=48)
ax.set_title("Sensitivity to " + r"$n$", fontsize=60, y=1.03)

ax.legend(fontsize=48, loc='upper right')
ax.tick_params(labelsize=48)
# ax = axes[1]
# for axis in ['top','bottom','left','right']:
#     ax.spines[axis].set_linewidth(2)

# with open(file="calibration_bns_cmc_after.pickle", mode='rb') as f:
#     bns = list(pickle.load(f))
# with open(file="calibration_y_cmc_after.pickle", mode='rb') as f:
#     y = list(pickle.load(f))

# print(f"bns: {bns}")
# print(f"y: {y}")

# # plt.figure(figsize=(10, 8))  # width:20, height:3
# ax.axline((0, 0), slope=1, color='k', linestyle='--', linewidth=2)
# ax.bar(bns, bns, align='edge', width=0.1, color='#FF1F5B', alpha=0.5, label='Expected', edgecolor='black', linewidth=2)
# ax.bar(bns, y, align='edge', width=0.1, color='#009ADE', alpha=0.8, label='Actual', edgecolor='black', linewidth=2)
# ax.set_xlabel('Confidence', fontsize=36)
# ax.set_ylabel('Accuracy', fontsize=36)
# ax.set_title("Reliability Diagram\nAfter Calibration", fontsize=42, y=1.03)
# ax.tick_params(labelsize=36)


# In[58]:


import matplotlib.pyplot as plt
from brokenaxes import brokenaxes
import numpy as np

baseline_names = ['Ours', 'DDA', 'MEMO', 'SHOT']
adaptation_time = [0.66, 45, 0.06182322210392264, 0.019105360032673595]

bax = brokenaxes(xlims=((0, 1.1), (44, 45.1)), hspace=1)
plt.title("Computational Efficiency", fontsize=32, y=1.02)
bax.set_xlabel('Average Adaptation Time (sec)', fontsize=28, labelpad=28)

bax.barh(range(len(adaptation_time)), adaptation_time, color=[colors2[3]] + ['lightgray'] * (len(adaptation_time) - 1), edgecolor='black')

bax.axs[0].set_yticks(list(range(len(baseline_names))), baseline_names, fontsize=28)
bax.axs[1].set_yticks(list(range(len(baseline_names))), baseline_names, fontsize=28)

bax.axs[0].set_xticks([0, 0.5, 1])
bax.axs[1].set_xticks([44, 44.5, 45])

bax.axs[0].tick_params(axis='x', labelsize=24)
bax.axs[1].tick_params(axis='x', labelsize=24)

bax.axs[0].grid(linestyle='--', linewidth=1)
bax.axs[1].grid(linestyle='--', linewidth=1)

bax.axs[0].spines['top'].set_visible(True)
bax.axs[1].spines['top'].set_visible(True)
bax.axs[1].spines['right'].set_visible(True)



# %%
# TODO: target label distribuion
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
import numpy as np

# Dataset and model lists
dataset_list = ["heloc", "anes", "diabetes_readmission", "mimic_extract_mort_hosp", "nhanes_lead", "brfss_diabetes"]
dataset_official_list = ["HELOC", "Voting", "Hospital Readmission", "ICU Mortality", "Childhood Lead", "Diabetes"]
model = "MLP"

# Plot settings
titlesize = 68
fontsize = 60
legendsize = 52
bar_width = 0.5  # Width of each bar
spacing = 0.3  # Factor to space out labels
margin = 0.05

fig, axes = plt.subplots(len(dataset_list), 4, figsize=(54, 10 * len(dataset_list)))
plt.subplots_adjust(top=0.99, bottom=0.01, hspace=0.45, wspace=0.3)

# Iterate through datasets
for i, dataset in enumerate(dataset_list):
    try:
        # Load the distributions
        with open(f"../pickle/{dataset}_{model}_0_Source Label Distribution_label_distribution.pickle", "rb") as f:
            src_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_Target Label Distribution_label_distribution.pickle", "rb") as f:
            tgt_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_Pseudo Label Distribution_label_distribution.pickle", "rb") as f:
            pl_density = pickle.load(f)
        with open(f"../pickle/{dataset}_{model}_0_AdapTable Label Distribution_label_distribution.pickle", "rb") as f:
            ml_density = pickle.load(f)
    except Exception as e:
        print(f"{e=}")
        continue

    # if len(np.bincount(pl_density)) == 1:
    #     pl_density = np.concatenate([pl_density, 1])

    # Calculate densities (proportions)
    source_density = np.bincount(src_density) / len(src_density)
    target_density = np.bincount(tgt_density) / len(tgt_density)
    pseudo_density = np.bincount(pl_density) / len(pl_density)
    print(f"{len(pseudo_density)=}")

    if len(pseudo_density) == 1:
        pseudo_density = np.concatenate([pseudo_density, [0]])
    modified_density = np.bincount(ml_density) / len(ml_density)

    densities = [source_density, target_density, pseudo_density, modified_density]
    dist_names = [src_density, tgt_density, pl_density, ml_density]
    titles = ['(a) Source Label Distribution', '(b) Target Label Distribution', '(c) Pseudo Label Distribution', '(d) Label Distribution Handler']
    names = ['Source', 'Target', 'Pseudo', 'AdapTable']
    colors2 = ["#FFA500", "#1871DE", "#525252", "#F24141"]

    # Plotting
    for j, (density, dist_name, title, name, color) in enumerate(zip(densities, dist_names, titles, names, colors2)):
        ax = axes[i][j]
        for axis in ['top','bottom','left','right']:
            ax.spines[axis].set_linewidth(4)
        ax.xaxis.set_label_coords(0, -1e-2)

        # Adjust the x positions for spacing
        x_positions = np.arange(len(density)) * spacing
        x_positions[0] += margin
        x_positions[-1] -= margin

        print(f"{x_positions=}")
        
        # x_positions = [0.075, 0.225]
        x_positions = [0, 1]
        
        # Plot histogram with normalized densities and consistent bar width
        ax.bar(x_positions, density, width=bar_width, color=color, alpha=1, align='center', label=name, edgecolor='black', linewidth=3)
        sns.kdeplot(dist_name, ax=ax, color='gray', alpha=.2, bw_adjust=10, fill=True, edgecolor='black', linewidth=0)

        ax.set_ylabel('Ratio', fontsize=48)
        ax.set_xlabel('Label', fontsize=48, y=-0.1)
        ax.set_xticks(x_positions)
        ax.set_xticklabels(np.arange(len(density)))  # Ensure labels match the spacing
        ax.set_title(f"{title}\n({dataset_official_list[i]})", y=1.03, fontsize=52)
        ax.set_xlim(-1, 2)
        ax.set_ylim(0, 1.1)
        ax.tick_params(labelsize=48)

plt.show()
# %%
